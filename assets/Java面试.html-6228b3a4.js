import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,e as s}from"./app-92ce1f7e.js";const i={},t=s(`<h1 id="java面试" tabindex="-1"><a class="header-anchor" href="#java面试" aria-hidden="true">#</a> Java面试</h1><h2 id="基础面试题" tabindex="-1"><a class="header-anchor" href="#基础面试题" aria-hidden="true">#</a> 基础面试题</h2><h3 id="java八大基本类型" tabindex="-1"><a class="header-anchor" href="#java八大基本类型" aria-hidden="true">#</a> Java八大基本类型</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Java八大基本类型</b></summary><p><b style="color:#f19977;">答：Byte Short Int Long Float Double Char Boolean</b></p></details><h3 id="jar包和war包的区别" tabindex="-1"><a class="header-anchor" href="#jar包和war包的区别" aria-hidden="true">#</a> Jar包和War包的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Jar包和War包的区别</b></summary><p><b style="color:#f19977;">答：jar包就是别人写好的一些类，然后对这些类进行打包，开发人员可以将这些jar包引入到自己的项目中，使用这些类和属性。 jar包一般放在lib目录下。war包是一个web模块，可以直接运行，一般开发好的网站，打包后部署到tomcat的网站根目录下，然后重启tomcat，这个包就可以自动解压，相当于代码发布。</b></p></details><h3 id="string类中常用的方法" tabindex="-1"><a class="header-anchor" href="#string类中常用的方法" aria-hidden="true">#</a> String类中常用的方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：String类中常用的方法</b></summary><p><b style="color:#f19977;">答：indexof()从指定字符提取索引位置、replace()替换、subString()截取字符串、equals()比较、split()把字符串分割成字符串数组</b></p></details><h3 id="什么是重载和重写" tabindex="-1"><a class="header-anchor" href="#什么是重载和重写" aria-hidden="true">#</a> 什么是重载和重写</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：什么是重载和重写</b></summary><p><b style="color:#f19977;">答：Java里面方法的重写和重载就是指Java的多态。重写就是父类和子类之间的多态，方法名和参数都一样。重载是一个类中方法的多态，方法名相同而参数不同。</b></p></details><h3 id="string中-和equals的区别" tabindex="-1"><a class="header-anchor" href="#string中-和equals的区别" aria-hidden="true">#</a> String中 == 和equals的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：String中的 == 和equals的区别</b></summary><p><b style="color:#f19977;">答：对于八大基本类型 == 比较的是值。对于引用类型来说 == 比较的是内存地址，equals比较的是内容。</b></p></details><h3 id="string-stringbuilder-stringbuffer三者的区别" tabindex="-1"><a class="header-anchor" href="#string-stringbuilder-stringbuffer三者的区别" aria-hidden="true">#</a> String StringBuilder StringBuffer三者的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：String StringBuilder StringBuffer三者的区别</b></summary><p><b style="color:#f19977;">答：在开发中String主要用于少量字符串的操作，因为它是final修饰的，是不可变字符串。StringBuffer主要用于可变的字符串，因为其有append方法。另外它是线程安全的。StringBuilder也是拼接字符串的，初始化创建一个对象，用append进行拼接，不会创建新对象。</b></p></details><h3 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字" aria-hidden="true">#</a> Final关键字</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：说说Final关键字</b></summary><p><b style="color:#f19977;">答：Final是一个安全修饰符，Final修饰的类不能被继承，Final声明的方法不能被重写。Final声明的变量不能被修改。</b></p></details><h3 id="java里可不可以有多继承" tabindex="-1"><a class="header-anchor" href="#java里可不可以有多继承" aria-hidden="true">#</a> Java里可不可以有多继承</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Java里可不可以有多继承</b></summary><p><b style="color:#f19977;">答：不可以，想多继承的话用接口</b></p></details><h3 id="java三大特性" tabindex="-1"><a class="header-anchor" href="#java三大特性" aria-hidden="true">#</a> Java三大特性</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Java三大特性</b></summary><p><b style="color:#f19977;">答：分别是封装、继承、多态。封装就是把一个事物有的方法和属性封装成对象。继承的体现就是让我们可以复用父类里面的代码。多态就是Java里面的继承、重写、重载。</b></p></details><h3 id="arraylist的底层" tabindex="-1"><a class="header-anchor" href="#arraylist的底层" aria-hidden="true">#</a> ArrayList的底层</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：ArrayList的底层</b></summary><p><b style="color:#f19977;">答：ArrayList是基于数组实现的，是一个动态数组。底层维护了一个Object类型的数组elementData。如果使用无参构造器，则初始elementData容量为0，第一次添加扩容为10，之后如需再次扩容，则扩容为elementData的1.5倍。如果使用指定大小的构造器则初始elementData容量为指定大小，如果需要扩容，则直接扩容为elementData的1.5倍。另外ArrayList是线程不安全的。</b></p></details><h3 id="arraylist与linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#arraylist与linkedlist的区别" aria-hidden="true">#</a> ArrayList与LinkedList的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：ArrayList与LinkedList的区别</b></summary><p><b style="color:#f19977;">答：ArrayList使用数组的方式存储数据，所以根据索引查询数据速度快，而增加和删除时需要移位操作所以慢。LinkedList使用双向链接的方式存储数据，所以插入和删除数据时只需更改前后元素的指针指向即可，速度非常快。</b></p></details><h3 id="hashmap的底层实现原理" tabindex="-1"><a class="header-anchor" href="#hashmap的底层实现原理" aria-hidden="true">#</a> HashMap的底层实现原理</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：HashMap的底层实现原理</b></summary><p><b style="color:#f19977;">答：HashMap的底层是数组+链表+红黑树。数组的初始大小是16，每个数组存储着一个链表。存数据时先根据Key的hashcode值计算出hash值，然后用hash值确定在数组中的位置，如果此位置没有东西则直接放入，如果有就会生成链表，把新的放入链表尾部。当取值时，会先根据Key的hashcode值计算出hash值，确定在数组中的位置，再根据equals方法从该位置上的链表中取出value值。如果数组的长度大于64并且链表的长度大于8就会树化成红黑树。数组扩容倍数是2倍。</b></p></details><h3 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：泛型</b></summary><p><b style="color:#f19977;">答：泛型是JDK1.5以后有的，我觉得它的好处就是让集合变得更安全一些，省去了强制转换。</b></p></details><h3 id="thread类中的常用方法" tabindex="-1"><a class="header-anchor" href="#thread类中的常用方法" aria-hidden="true">#</a> Thread类中的常用方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Thread类中的常用方法</b></summary><p><b style="color:#f19977;">答：<br>start() 启动线程，并执行线程的run()方法<br>run() 线程的执行体<br>sleep() 让当前线程睡眠指定的毫秒数 <br>setName() 设置线程名称<br>getName() 获取线程名称<br>setPriority(int priority) 设置线程的优先级<br>getPriority() 获取线程的优先级</b></p></details><h3 id="说五个开发中常见的异常" tabindex="-1"><a class="header-anchor" href="#说五个开发中常见的异常" aria-hidden="true">#</a> 说五个开发中常见的异常</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：说五个开发中常见的异常</b></summary><p><b style="color:#f19977;">答：IO异常、空指针异常、数组下标越界异常、文件未找到异常、Sql异常</b></p></details><h3 id="接口和抽象类的异同" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的异同" aria-hidden="true">#</a> 接口和抽象类的异同</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：接口和抽象类的异同</b></summary><p><b style="color:#f19977;">答：<br>相同点：<br>接口和抽象类都是抽象的，不能直接实例化，只能被子类实现或继承，并且可以包含抽象方法（没有具体实现）,接口和抽象类都用于定义一种规范或者协议，描述类应该具备的行为和功能。<br>不同点：<br>接口中的方法都是抽象的，不能有具体的实现；而抽象类中可以包含具体的方法实现，也可以包含抽象方法。Java中一个类只能继承一个父类，但是可以实现多个接口。因此，接口支持多继承，而抽象类不支持多继承。接口中的变量默认是public static final类型的常量，不能被修改；抽象类中可以定义实例变量，并且可以有各种访问控制修饰符。接口中不能包含构造方法；抽象类可以包含构造方法，用于被子类调用。接口主要用于实现类之间的解耦，描述类应该具备的行为，强调规范和契约；而抽象类主要用于作为其他类的基类，提取共性的方法和属性，强调类的继承关系和代码复用。</b></p></details><h3 id="创建对象的几种方法" tabindex="-1"><a class="header-anchor" href="#创建对象的几种方法" aria-hidden="true">#</a> 创建对象的几种方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：创建对象的几种方法</b></summary><p><b style="color:#f19977;">答：<br>第一种：使用new关键字<br>第二种：通过反射，可以根据类名来创建对象。Class.forName(&quot;com.example.MyClass&quot;);<br>第三种：使用Class类的newInstance()方法：该方法会调用类的默认构造方法来创建对象，要求类必须有无参构造函数<br>第四种：使用clone()方法：通过复制一个现有对象来创建一个新对象，要求被复制的类必须实现Cloneable接口，并且覆盖clone()方法。</b></p></details><h3 id="线程池的核心参数" tabindex="-1"><a class="header-anchor" href="#线程池的核心参数" aria-hidden="true">#</a> 线程池的核心参数</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：线程池的核心参数</b></summary><p><b style="color:#f19977;">答：<br>核心线程数<br>最大线程数<br>线程空闲时间<br>时间单位<br>任务队列<br>线程工厂<br>拒绝策略</b></p></details><h3 id="创建线程池的几种方法" tabindex="-1"><a class="header-anchor" href="#创建线程池的几种方法" aria-hidden="true">#</a> 创建线程池的几种方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：创建线程池的几种方法</b></summary><p><b style="color:#f19977;">答：<br>第一种：使用Executors工厂类<br>第二种：使用ThreadPoolExecutor类<br>第三种：使用ScheduledThreadPoolExecutor类</b></p></details><h3 id="java实现多线程的方法" tabindex="-1"><a class="header-anchor" href="#java实现多线程的方法" aria-hidden="true">#</a> Java实现多线程的方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Java实现多线程的方法</b></summary><p><b style="color:#f19977;">答：继承Thread类、因为Java是单继承。所以还可以实现Runnable接口</b></p></details><h3 id="多线程怎么解决高并发" tabindex="-1"><a class="header-anchor" href="#多线程怎么解决高并发" aria-hidden="true">#</a> 多线程怎么解决高并发</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：多线程怎么解决高并发</b></summary><p><b style="color:#f19977;">答：有两种。一种是Synchronized是利用锁的机制，使变量和代码块在某一时只能被一个线程访问。二是ThreadLocal其为每一个线程都提供变量的副本，使得每个线程在某一时间访问到的并不是同一对象，这样就隔离了多个线程对数据的数据共享。</b></p></details><h3 id="jvm内存分析-解释下堆和栈" tabindex="-1"><a class="header-anchor" href="#jvm内存分析-解释下堆和栈" aria-hidden="true">#</a> JVM内存分析，解释下堆和栈</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：JVM内存分析，解释下堆和栈</b></summary><p><b style="color:#f19977;">答：JVM内存结构主要分为堆内存、方法区和栈。堆内存时JVM中最大的一块内存地址。所有new出来的对象都存储在该区域。栈就是暂存数据的地方，栈中只保存基础数据类型的对象和自定义对象的引用，每个栈中的数据都是私有的，其它栈不能访问。方法区存放了要加载的类的信息如类名、修饰符、静态变量、构造函数等</b></p></details><h3 id="什么是反射-能干嘛" tabindex="-1"><a class="header-anchor" href="#什么是反射-能干嘛" aria-hidden="true">#</a> 什么是反射，能干嘛</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：什么是反射，能干嘛</b></summary><p><b style="color:#f19977;">答：反射就是将类的各个组成部分封装成其它对象。在Java中只要知道类的名字，通过Class.forName方法可以获得到类对象。通过Class类对象就可以获得类的所有信息。比如类中的成员变量和方法。我们可以对类里的这些方法进行执行或者用动态代理模式进行增强。我们常用的Spring和MyBatis框架就是利用Java反射+动态代理的技术编写的。</b></p></details><h3 id="get和post请求的区别" tabindex="-1"><a class="header-anchor" href="#get和post请求的区别" aria-hidden="true">#</a> Get和Post请求的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Get和Post请求的区别</b></summary><p><b style="color:#f19977;">答：Get是用URL传递数据的，不是很安全。而且传递的数据量比较小。Post是可以传递大数据量的。</b></p></details><h3 id="session和cookie的区别" tabindex="-1"><a class="header-anchor" href="#session和cookie的区别" aria-hidden="true">#</a> Session和Cookie的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Session和Cookie的区别</b></summary><p><b style="color:#f19977;">答：Session是保存到服务器端的。Cookie是保存到客户端上的。Session相对于Cookie来说更安全。</b></p></details><h3 id="转发和重定向的区别" tabindex="-1"><a class="header-anchor" href="#转发和重定向的区别" aria-hidden="true">#</a> 转发和重定向的区别</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：转发和重定向的区别</b></summary><p><b style="color:#f19977;">答：重定向就是RequestDispatcher.forward只能将请求转发给同一个项目中而且可以携带数据。而转发可以跳转到当前项目中的页面也可以跳转到其他项目中的页面但是不能携带数据。</b></p></details><h3 id="类的初始化过程" tabindex="-1"><a class="header-anchor" href="#类的初始化过程" aria-hidden="true">#</a> 类的初始化过程</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：类的初始化过程</b></summary><p><b style="color:#f19977;">答：加载Class文件进内存，在栈内存开辟空间，在堆内存为对象开辟空间，对对象的成员变量进行默认初始化，对对象的成员变量进行显示初始化。通过构造方法对对象的成员变量赋值，把对象地址赋值给变量。</b></p></details><h3 id="为什么要同时重写hashcode和equals方法" tabindex="-1"><a class="header-anchor" href="#为什么要同时重写hashcode和equals方法" aria-hidden="true">#</a> 为什么要同时重写HashCode和Equals方法</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：为什么要同时重写HashCode和Equals方法</b></summary><p><b style="color:#f19977;">答：重写Equals方法是为了比较两个不同对象的值是否相等。重写HashCode方法是为了让同一个Class对象的两个具有相同值的对象的Hash值相等。同时重写HashCode和Equals是为了满足HashMap等集合的相同对象的不重复存储。</b></p></details><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：单例模式</b></summary><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class Singleton
{
    private static Singleton instance;

    private Singleton(){}

    private static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }

    public void show(){
        System.out.println(&quot;我是单例模式&quot;);
    }

    public static void main(String[] args){
        Singleton s1 = Singleton.getInstance();
        s1.show();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="后端框架" tabindex="-1"><a class="header-anchor" href="#后端框架" aria-hidden="true">#</a> 后端框架</h2><h3 id="对spring的理解" tabindex="-1"><a class="header-anchor" href="#对spring的理解" aria-hidden="true">#</a> 对Spring的理解</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：对Spring的理解</b></summary><p><b style="color:#f19977;">答：Spring核心思想为IOC、DI、AOP。Spring框架使用了Java里面的反射机制。IOC就是把对象的创建控制权转移到IOC容器并且负责对象的创建、初始化等一系列工作。被创建的对象在IOC容器中称为Bean。在容器中建立Bean与Bean之间的关系就称为依赖注入。AOP底层是代理模式，可以在不改变原有代码结构的情况下增强功能。</b></p></details><h3 id="aop有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#aop有哪些应用场景" aria-hidden="true">#</a> AOP有哪些应用场景</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：AOP有哪些应用场景</b></summary><p><b style="color:#f19977;">答：事务管理、日志打印。</b></p></details><h3 id="spring-中-autowired-和-resource-的区别" tabindex="-1"><a class="header-anchor" href="#spring-中-autowired-和-resource-的区别" aria-hidden="true">#</a> Spring 中@Autowired 和@Resource 的区别?</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Spring 中@Autowired 和@Resource 的区别?</b></summary><p><b style="color:#f19977;">答：@Autowired是按照类型进行注入，没有类型会按照名称进行注入。@Resource会按照名称注入，名称找不着会按照类型来找。</b></p></details><h3 id="spring-事务失效场景" tabindex="-1"><a class="header-anchor" href="#spring-事务失效场景" aria-hidden="true">#</a> Spring 事务失效场景</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Spring事务失效场景</b></summary><p><b style="color:#f19977;">答：Spring中的事务是使用@Transaction注解。<br>失效场景一： 是@Transaction只能使用在public方法上，如果使用在非public方法上会失效。<br>失效场景二： 是在一个没有标记为@Transaction方法的内部调用了同一个类中标记为@Transaction注解的方法的时候事务是不会生效的，可以考虑方法设计和拆分。</b></p></details><h3 id="spring-事务传播机制" tabindex="-1"><a class="header-anchor" href="#spring-事务传播机制" aria-hidden="true">#</a> Spring 事务传播机制</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Spring 事务传播机制</b></summary><p><b style="color:#f19977;">答：<br>第一种：如果存在事务，则加入事务；如果当前没有事务，则新建一个事务。<br>第二种：如果存在事务，则加入事务；如果当前没有事务，则以非事务状态执行。<br>第三种：总是以非事务状态执行操作，如果当前存在事务，则挂起当前事务。<br>第四种：总是以非事务状态执行操作，如果当前存在事务，则抛出异常。</b></p></details><h3 id="说一下springboot" tabindex="-1"><a class="header-anchor" href="#说一下springboot" aria-hidden="true">#</a> 说一下SpringBoot</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：说一下SpringBoot</b></summary><p><b style="color:#f19977;">答：SpringBoot一个重要的思想是约定大于配置，其整合了所有的后端框架。优点有能快速创建独立运行的Spring项目以及与主流框架集成。大量的自动配置，简化开发。无需配置大量的XML文件，开箱即用。</b></p></details><h3 id="springboot自动装配原理" tabindex="-1"><a class="header-anchor" href="#springboot自动装配原理" aria-hidden="true">#</a> Springboot自动装配原理</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Springboot自动装配原理</b></summary><p><b style="color:#f19977;">答：自动装配简单来说就是自动去把第三方组件的Bean装载到IOC容器里面，不需要开发人员再去写Bean相关的配置。在SpringBoot里面只需要加入@SpringBootApplication就能实现自动装配，@SpringBootApplication是一个复合注解，真正起作用的是@EnableAutoConfiguration注解。Spring Boot的自动装配原理基于条件化配置和自动扫描机制。通过在启动时自动扫描项目的类路径，寻找标有@EnableAutoConfiguration注解的类，以及预定义的Starter POM中包含的自动配置类，Spring Boot能够根据条件化注解（如@ConditionalOnClass、@ConditionalOnBean、@ConditionalOnProperty等）来判断自动配置是否生效。这样，Spring Boot能够根据项目的依赖和配置自动选择合适的配置方案，使得开发者可以更加专注于业务逻辑的实现，而无需过多关注底层的配置和集成细节。</b></p></details><h3 id="spring的三种注入方式" tabindex="-1"><a class="header-anchor" href="#spring的三种注入方式" aria-hidden="true">#</a> Spring的三种注入方式</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Spring的三种注入方式</b></summary><p><b style="color:#f19977;">答：配置包扫描、seter方式和构造方法的方式</b></p></details><h3 id="为什么bean要设计成单例" tabindex="-1"><a class="header-anchor" href="#为什么bean要设计成单例" aria-hidden="true">#</a> 为什么Bean要设计成单例</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：为什么Bean要设计成单例</b></summary><p><b style="color:#f19977;">答：资源利用效率：单例模式可以节省系统资源，避免重复创建和销毁对象。当一个对象被多次请求时，只需要创建一次实例并重复使用，提高了系统的资源利用效率。对象一致性：对于某些需要保持一致状态或共享数据的对象，使用单例模式可以确保全局只有一个实例。这样可以避免多个实例之间的数据不一致性问题，简化了数据管理和同步的复杂性。全局访问性：单例模式使得对象在整个应用程序的上下文中可被访问。这对于需要在不同的组件或模块中共享数据或提供共享服务的对象非常有用。配置和管理简便性：在Spring框架中，Bean的单例模式使得对象的创建、依赖注入和生命周期管理更加简便。通过Spring容器的管理，可以统一配置和管理Bean的创建和销毁过程。</b></p></details><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库" aria-hidden="true">#</a> 数据库</h2><h3 id="介绍一下redis" tabindex="-1"><a class="header-anchor" href="#介绍一下redis" aria-hidden="true">#</a> 介绍一下Redis</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：介绍一下Redis</b></summary><p><b style="color:#f19977;">答：Redis是一个非关系型数据库。项目中主要用它来存储热点数据，减轻数据库的压力。有很多地方都用到了Redis，比如商品的秒杀，首页热点数据的显示等等。</b></p></details><h3 id="项目中是怎么操作redis的" tabindex="-1"><a class="header-anchor" href="#项目中是怎么操作redis的" aria-hidden="true">#</a> 项目中是怎么操作Redis的</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：项目中是怎么操作Redis的</b></summary><p><b style="color:#f19977;">答：通过RedisTemplate类操作Redis</b></p></details><h3 id="redis的数据类型" tabindex="-1"><a class="header-anchor" href="#redis的数据类型" aria-hidden="true">#</a> Redis的数据类型</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Redis的数据类型</b></summary><p><b style="color:#f19977;">答：String、List、Set、Hash、SortedSte有序集合</b></p></details><h3 id="redis是如何同步的" tabindex="-1"><a class="header-anchor" href="#redis是如何同步的" aria-hidden="true">#</a> Redis是如何同步的</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Redis是如何同步的</b></summary><p><b style="color:#f19977;">答：两种解决方案，先更新数据库再更新缓存。但是更新缓存失败的话也不能实现数据同步。第二种是先删除缓存再更新数据库，但由于这两步操作不是原子性的也有可能会失败。</b></p></details><h3 id="mybatis缓存机制" tabindex="-1"><a class="header-anchor" href="#mybatis缓存机制" aria-hidden="true">#</a> Mybatis缓存机制</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Mybatis缓存机制</b></summary><p><b style="color:#f19977;">答：一级缓存是MyBatis默认开启的缓存机制，它是指在同一个SqlSession内的缓存。当进行相同的查询时，如果该查询的结果已经在当前SqlSession的本地缓存中存在，则直接从缓存中获取结果，而不再去数据库查询。本地缓存的作用域是SqlSession，当SqlSession关闭时，本地缓存也会被清空。<br>二级缓存是指在SqlSessionFactory层面的缓存，它可以被多个SqlSession共享。当多个SqlSession执行相同的查询时，如果查询结果已经存在于二级缓存中，则直接从缓存中获取结果，而不会再去数据库查询。二级缓存的作用域是SqlSessionFactory，在整个应用的生命周期内有效。需要注意的是，二级缓存需要在MyBatis的配置文件中明确地配置开启。</b></p></details><h3 id="解释一下什么是索引" tabindex="-1"><a class="header-anchor" href="#解释一下什么是索引" aria-hidden="true">#</a> 解释一下什么是索引</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：解释一下什么是索引</b></summary><p><b style="color:#f19977;">答：索引可以理解为数据的查询目录，建索引的目的就是为了提高对表的查询速度。</b></p></details><h3 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化" aria-hidden="true">#</a> SQL优化</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：SQL优化</b></summary><p><b style="color:#f19977;">答：使用合适的索引、优化查询语句、避免全表扫描、</b></p></details><h2 id="项目相关" tabindex="-1"><a class="header-anchor" href="#项目相关" aria-hidden="true">#</a> 项目相关</h2><h3 id="四种请求方式" tabindex="-1"><a class="header-anchor" href="#四种请求方式" aria-hidden="true">#</a> 四种请求方式</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：四种请求方式</b></summary><p><b style="color:#f19977;">GET<br>POST<br>PUT<br>DELETE <br></b></p></details><h3 id="token登录流程" tabindex="-1"><a class="header-anchor" href="#token登录流程" aria-hidden="true">#</a> token登录流程</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：token登录流程</b></summary><p><b style="color:#f19977;">答：把用户名和密码通过请求发送到后端，后端验证用户名和密码，验证成功后生成token返回给前端，前端把token保存到本地存储，每次请求前，通过axios请求拦截器，统一发送token。通过vue导航守卫，和axios响应拦截器，统一保护页面。</b></p></details><h3 id="各类默认端口号" tabindex="-1"><a class="header-anchor" href="#各类默认端口号" aria-hidden="true">#</a> 各类默认端口号</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：各类默认端口号</b></summary><p><b style="color:#f19977;">tomcat：8080 <br>MySql: 3306<br>Redis: 6379<br>Http：80 <br>Https: 443</b></p></details><h3 id="http各类状态码" tabindex="-1"><a class="header-anchor" href="#http各类状态码" aria-hidden="true">#</a> Http各类状态码</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：Http各类状态码</b></summary><b style="color:#f19977;"> 1xx 信息性状态码: <br> 100 Continue：服务器已收到请求的一部分，客户端应继续发送剩余部分。<br> 101 Switching Protocols：服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端更改协议。<br> 其他1xx状态码用于协议交互中。<br><br> 2xx 成功状态码：<br> 200 OK：请求已成功。<br> 201 Created：请求已经被实现，并且创建了新的资源。<br> 204 No Content：服务器成功处理了请求，但没有返回任何内容。<br><br> 3xx 重定向状态码：<br> 301 Moved Permanently：请求的资源已永久移动到新位置。<br> 302 Found：请求的资源已暂时移动到新位置。<br> 304 Not Modified：客户端发送的请求已经存在且未修改，服务器告诉客户端使用本地缓存版本。<br><br> 4xx 客户端错误状态码：<br> 400 Bad Request：请求无效。<br> 401 Unauthorized：请求要求用户身份认证。<br> 403 Forbidden：服务器理解请求，但拒绝执行。<br> 404 Not Found：请求的资源未找到。<br><br> 5xx 服务器错误状态码：<br> 500 Internal Server Error：服务器遇到了一个未知的错误。<br> 502 Bad Gateway：服务器作为网关或代理时收到了无效的响应。<br> 503 Service Unavailable：服务器暂时过载或维护，无法处理请求。<br> 504 Gateway Timeout：服务器作为网关或代理时未及时从上游服务器收到请求。</b></details><h3 id="token过期问题" tabindex="-1"><a class="header-anchor" href="#token过期问题" aria-hidden="true">#</a> token过期问题</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：token过期问题</b></summary><p><b style="color:#f19977;">使用Refresh Token: 除了主要的登录Token，还可以使用Refresh Token。 Refresh<br> Token是一个长期有效的Token， 用于获取新的短期有效的登录Token。当登录Token过期时，前端使用Refresh Token向后端请求新的登录Token。后端会验证Refresh Token的有效性，并生成一个新的登录Token返回给前端。前端接收到新的登录Token 后，将其保存在本地并替换旧的过期Token。</b></p></details><h2 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h2><h3 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h3><details class="hint-container details"><summary><b style="color:#bf3e73;">问：冒泡排序</b></summary><p><b style="color:#f19977;">答：比较相邻的两个元素，如果第一个比第二个大，则交换。每一次循环最后面的就是最大的。重复以上步骤。</b></p></details>`,108),n=[t];function l(d,o){return e(),r("div",null,n)}const c=a(i,[["render",l],["__file","Java面试.html.vue"]]);export{c as default};
